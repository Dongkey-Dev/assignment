/**
 * @packageDocumentation
 * @module api.functional.api.v1.events
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection, Resolved, Primitive } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import type { Pattern } from "typia/lib/tags/Pattern";

import type {
  CreateEventDto,
  EventResponseDto,
} from "../../../../../libs/shared/src/dtos/event.dto";

/**
 * 이벤트 등록
 *
 * name: 이벤트 이름
 *
 * conditions.actionType: 'LOGIN' | 'PURCHASE' | 'INVITE_FRIEND' | 'ACHIEVEMENT'
 *
 * conditions.conditionType: 'cumulative' | 'once'
 *
 * conditions.targetCount: 조건을 충족해야 하는 횟수
 *
 * conditions.targetCountQuery: 조건을 충족해야 하는 대상
 *
 * conditions.targetCountQuery.targetCollection: 조건을 충족해야 하는 대상 컬렉션
 *
 * conditions.targetCountQuery.filter: 조건을 충족해야 하는 대상 필터
 *
 * conditions.context: 조건의 컨텍스트
 *
 * conditions.context.targetType: 조건의 타겟 타입 'USER' | 'QUEST' | 'EVENT' | 'PRODUCT'
 *
 * conditions.context.targetIdField: 조건의 타겟 ID 필드
 *
 * conditions.period: 조건의 기간
 *
 * conditions.period.start: 조건의 시작 시간
 *
 * conditions.period.end: 조건의 종료 시간
 *
 * conditions.status: 'active' | 'inactive'
 *
 * @tag events
 * @security bearer
 * @summary 새로운 이벤트를 등록합니다
 *
 * @controller EventsController.createEvent
 * @path POST /api/v1/events
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function createEvent(
  connection: IConnection,
  _createEventDto: createEvent.Input,
): Promise<createEvent.Output> {
  return PlainFetcher.fetch(
    {
      ...connection,
      headers: {
        ...connection.headers,
        "Content-Type": "application/json",
      },
    },
    {
      ...createEvent.METADATA,
      template: createEvent.METADATA.path,
      path: createEvent.path(),
    },
    _createEventDto,
  );
}
export namespace createEvent {
  export type Input = Resolved<CreateEventDto>;
  export type Output = Primitive<EventResponseDto>;

  export const METADATA = {
    method: "POST",
    path: "/api/v1/events",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 201,
  } as const;

  export const path = () => "/api/v1/events";
}

/**
 * 이벤트 조회
 *
 * @tag events
 * @security bearer
 * @summary ID로 이벤트를 조회합니다
 *
 * @controller EventsController.getEvent
 * @path GET /api/v1/events/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getEvent(
  connection: IConnection,
  _id: string & Pattern<"^[a-fA-F0-9]{24}$">,
): Promise<getEvent.Output> {
  return PlainFetcher.fetch(connection, {
    ...getEvent.METADATA,
    template: getEvent.METADATA.path,
    path: getEvent.path(_id),
  });
}
export namespace getEvent {
  export type Output = Primitive<EventResponseDto>;

  export const METADATA = {
    method: "GET",
    path: "/api/v1/events/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 200,
  } as const;

  export const path = (_id: string & Pattern<"^[a-fA-F0-9]{24}$">) =>
    `/api/v1/events/${encodeURIComponent(_id?.toString() ?? "null")}`;
}

/**
 * 전체 이벤트 조회
 *
 * @tag events
 * @security bearer
 * @summary 모든 이벤트 목록을 조회합니다
 *
 * @controller EventsController.getAllEvents
 * @path GET /api/v1/events
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getAllEvents(
  connection: IConnection,
): Promise<getAllEvents.Output> {
  return PlainFetcher.fetch(connection, {
    ...getAllEvents.METADATA,
    template: getAllEvents.METADATA.path,
    path: getAllEvents.path(),
  });
}
export namespace getAllEvents {
  export type Output = Primitive<Array<EventResponseDto>>;

  export const METADATA = {
    method: "GET",
    path: "/api/v1/events",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 200,
  } as const;

  export const path = () => "/api/v1/events";
}
